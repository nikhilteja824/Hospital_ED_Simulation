# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ju66hlSxDfiWdZEOnanHKtUILZuetpwt
"""

# from google.colab import drive
# drive.mount('/content/drive')

# cd /content/drive/MyDrive/Sim_Mod_Proj/

# !pip install simpy

import simpy
import random
import datetime
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import interp1d
import pandas as pd
import os
import json
import seaborn as sns


def generate_interarrival_times(num_patients, lambda_rate=1):
    """
    Generate interarrival times using an exponential distribution.

    Args:
    - num_patients (int): Total number of patients.
    - lambda_rate (float): Rate parameter (λ) in events per minute. 
                           (e.g., λ = 2 means 2 patients arrive per minute).

    Returns:
    - interarrival_times (list): Generated interarrival times (in seconds).
    """
    # Generate interarrival times as exponential random variables
    interarrival_times = np.random.exponential(scale=1/lambda_rate, size=num_patients)

    # Convert times from minutes to seconds for the simulation
    interarrival_times = (interarrival_times * 60).astype(int)

    return interarrival_times


# Generate intervals using interpolation
def interval_gen(num_patients):
    # x_data = np.arange(len(BASELINE_ARRIVALS))
    # y_data = np.array(BASELINE_ARRIVALS).reshape(len(BASELINE_ARRIVALS),)

    # # Interpolate to 100 values
    # interp = interp1d(x_data, y_data, kind='cubic')
    # x_interp = np.linspace(0, len(BASELINE_ARRIVALS)-1, num_patients)
    # y_interp = interp(x_interp)
    # y_out = np.interp(y_interp, (0, max(y_data)), (0, max(y_data)))
    # return np.asarray(y_out, dtype = 'int')
    """
    Generate interarrival times dynamically for the simulation.

    Args:
    - num_patients (int): Total number of patients.

    Returns:
    - interarrival_times (list): Generated interarrival times (in seconds).
    """
    lambda_rate = 0.3
    return generate_interarrival_times(num_patients, lambda_rate)


# Helper function to generate random consultation decisions
def consultation_decision():
    return random.random() < 0.5

# Helper function to generate random scan/xray decisions
def ip_decision():
    return random.choices([0, 1], weights=[0.66666, 0.33333])[0]

def oldOP_scan_decision():
    # return random.randint(0,4)
    return random.choices([0, 1, 2, 3, 4], weights=[0.08333, 0.16666, 0.08333, 0.33333, 0.33333])[0]

def NewOP_decision():
    return random.choices([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], weights=[0.15, 0.1, 0.05, 0.05, 0.1, 0.3, 0.05, 0.05, 0.05, 0.05, 0.05])[0]

def OldOP_decision():
    return random.choices([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], weights=[0.03846, 0.03846, 0.07692, 0.07692, 0.03846, 0.19230, 0.07692, 0.15384, 0.23076, 0.07692])[0]

# Helper: Assign criticality
def assign_criticality():
    return random.choices(['Level 1', 'Level 2', 'Level 3'], weights=[0.3, 0.4, 0.3])[0]

# Helper: Assign category
def p_type():
    return random.choices(['NewOP', 'OldOP', 'OldOPScan', 'IP'], weights=[0.328, 0.358, 0.179, 0.134])[0]

# Create the patient arrival process
def patient_arrival(env, bedspaces, doctors, registration, xray, scan, dressing, injection, pharmacy, billing, f):
    intervals = interval_gen(NUM_PATIENTS)
    for i in range(NUM_PATIENTS):
        # delays.append(intervals[i])
        yield env.timeout(intervals[i])
        current_time = datetime.datetime.fromtimestamp(env.now).time()
        print("Patient %d arrives at the hospital at %s." % (i, current_time.strftime('%X %p')), file=f)
        env.process(patient_flow(env, bedspaces, doctors, registration, xray, scan, dressing, injection, pharmacy, billing, "Patient %d" % i, f))

# Create the registration process
def registration_process(env, registration, patient, f):
    global end, num_registration, reg_delay_times, reg_service_times
    num_registration += 1
    print("%s arriving at the registration desk at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    processing_time = REGISTRATION_TIME + np.random.uniform(0, 5)
    with registration.request() as req:
        yield req
        start_time = env.now
        print("%s starting registration process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing registration process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %s minutes at the registration desk" % (patient, total_delay_time), file=f)
    reg_delay_times.append(total_delay_time)
    reg_service_times.append(processing_time)
    flow[patient].update({
        'Registration': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })
    return total_delay_time

# Create the bedspace allocation process
def bedspace_allocation(env, bedspace, patient, criticality, f):
    global num_bedspace, bedspace_delay_times, bedspace_service_times
    num_bedspace += 1
    print("%s arriving for bed allocation with %s criticality at %s." % (patient, criticality, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    while env.now < datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp():
        yield env.timeout(60)
    with bedspace.request(priority=(0 if criticality == 'Level 1' else 1 if criticality == 'Level 2' else 2)) as req:
        yield req
        start_time = env.now
        print("%s starting bed allocation process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        processing_time = BEDSPACE_TIME + np.random.uniform(0, 5)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing bed allocation process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %.2f minutes for bed allocation." % (patient, total_delay_time), file=f)
    bedspace_delay_times.append(total_delay_time)
    bedspace_service_times.append(processing_time)
    flow[patient].update({
        'Bedspace Allocation': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time)),
            'occupancy': f"{processing_time:.2f} seconds"
        }
    })
    return total_delay_time

# Create the consultation process
def consultation(env, doctors, patient, f):
    global end, exit_time, num_consultation, cons_delay_times, cons_service_times
    # if env.now > datetime.datetime.combine(datetime.date.today(), datetime.time(18, 0)).timestamp():
    #     print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    #     end = 1
    #     exit_time = env.now
    #     return 0
    num_consultation += 1
    print("%s arriving at the consultation room at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    processing_time = CONSULTATION_TIME + np.random.uniform(0, 5)
    while env.now < datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp():
        yield env.timeout(60)
    with doctors.request() as req:
        yield req
        start_time = env.now
        print("%s starting consultation with a doctor at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing consultation with a doctor at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %s minutes at the consultation room" % (patient, total_delay_time), file=f)
    cons_delay_times.append(total_delay_time)
    cons_service_times.append(processing_time)
    flow[patient].update({
        'Consultation': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })
    return total_delay_time

# Repeat similar updates for all remaining processes

# Create the pharmacy process
def pharmacy_process(env, pharmacy, patient, f):
    global end, exit_time, num_pharmacy, phar_delay_times, phar_service_times
    # if env.now > datetime.datetime.combine(datetime.date.today(), datetime.time(18, 45)).timestamp():
    #     print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    #     end = 1
    #     exit_time = env.now
    #     return 0
    num_pharmacy += 1
    print("%s arriving at the pharmacy at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    processing_time = PHARMACY_TIME + np.random.uniform(0, 5)
    while env.now < datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp():
        yield env.timeout(60)
    with pharmacy.request() as req:
        yield req
        start_time = env.now
        print("%s starting pharmacy process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing pharmacy process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %s minutes at the pharmacy" % (patient, total_delay_time), file=f)
    phar_delay_times.append(total_delay_time)
    phar_service_times.append(processing_time)
    flow[patient].update({
        'Pharmacy': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })
    return total_delay_time

# Create the dressing process
def dressing_process(env, dressing, patient, f):
    global end, exit_time, num_dressing, dress_delay_times, dress_service_times

    # Check if time exceeds hospital closing time
    # if env.now > datetime.datetime.combine(datetime.date.today(), datetime.time(18, 45)).timestamp():
    #     print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    #     end = 1
    #     exit_time = env.now
    #     return 0  # Quit the service if time is greater than 6:45 PM

    # Increment the dressing counter
    num_dressing += 1

    # Log arrival
    print("%s arriving at the dressing desk at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now

    # Calculate processing time with variability
    processing_time = DRESSING_TIME + np.random.uniform(0, 5)

    # Ensure the process doesn't start before the hospital opening time
    while env.now < (datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp()):
        yield env.timeout(60)  # Check every minute

    # Request a dressing resource
    with dressing.request() as req:
        yield req  # Delay until the resource is available

        # Log the start time
        start_time = env.now
        print("%s starting dressing process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)

        # Simulate the dressing process
        yield env.timeout(processing_time)

        # Log the finish time
        finish_time = env.now
        print("%s finishing dressing process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)

    # Calculate and log the total delay time
    total_delay_time = (start_time - arrival_time) / 60  # Convert seconds to minutes
    print("%s delayed %.2f minutes at the dressing desk" % (patient, total_delay_time), file=f)

    # Update delay times and service times
    dress_delay_times.append(total_delay_time)
    dress_service_times.append(processing_time)

    # Update the flow dictionary with timestamps and delay time
    flow[patient].update({
        'Dressing': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })

    return total_delay_time



# Create the xray process
def xray_process(env, xray, patient, f):
    global end, exit_time, num_xray, xray_delay_times, xray_service_times
    # if env.now > datetime.datetime.combine(datetime.date.today(), datetime.time(18, 45)).timestamp():
    #     print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    #     end = 1
    #     exit_time = env.now
    #     return 0
    num_xray += 1
    print("%s arriving at the xray room at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    processing_time = XRAY_TIME + np.random.uniform(0, 5)
    while env.now < datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp():
        yield env.timeout(60)
    with xray.request() as req:
        yield req
        start_time = env.now
        print("%s starting xray process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing xray process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %s minutes at the xray room" % (patient, total_delay_time), file=f)
    xray_delay_times.append(total_delay_time)
    xray_service_times.append(processing_time)
    flow[patient].update({
        'Xray': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })
    return total_delay_time


# Create the scan process
def scan_process(env, scan, patient, f):
    global end, exit_time, num_scan, scan_delay_times, scan_service_times
    # if env.now > datetime.datetime.combine(datetime.date.today(), datetime.time(18, 45)).timestamp():
    #     print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    #     end = 1
    #     exit_time = env.now
    #     return 0
    num_scan += 1
    print("%s arriving at the scan room at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    processing_time = SCAN_TIME + np.random.uniform(0, 5)
    while env.now < datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp():
        yield env.timeout(60)
    with scan.request() as req:
        yield req
        start_time = env.now
        print("%s starting scan process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing scan process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %s minutes at the scan room" % (patient, total_delay_time), file=f)
    scan_delay_times.append(total_delay_time)
    scan_service_times.append(processing_time)
    flow[patient].update({
        'Scan': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })
    return total_delay_time


# Create the billing process
def billing_process(env, billing, patient, f):
    global end, exit_time, num_billing, bill_delay_times, bill_service_times
    # if env.now > datetime.datetime.combine(datetime.date.today(), datetime.time(18, 45)).timestamp():
    #     print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    #     end = 1
    #     exit_time = env.now
    #     return 0
    num_billing += 1
    print("%s arriving at the billing room at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    processing_time = BILLING_TIME + np.random.uniform(0, 5)
    while env.now < datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp():
        yield env.timeout(60)
    with billing.request() as req:
        yield req
        start_time = env.now
        print("%s starting billing process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing billing process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %s minutes at the billing room" % (patient, total_delay_time), file=f)
    bill_delay_times.append(total_delay_time)
    bill_service_times.append(processing_time)
    flow[patient].update({
        'Billing': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })
    return total_delay_time


# Create the injection process
def injection_process(env, injection, patient, f):
    global end, exit_time, num_injection, inj_delay_times, inj_service_times
    # if env.now > datetime.datetime.combine(datetime.date.today(), datetime.time(18, 45)).timestamp():
    #     print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    #     end = 1
    #     exit_time = env.now
    #     return 0
    num_injection += 1
    print("%s arriving at the injection room at %s." % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
    arrival_time = env.now
    processing_time = INJECTION_TIME + np.random.uniform(0, 5)
    while env.now < datetime.datetime.combine(datetime.date.today(), SERVICE_START_TIME).timestamp():
        yield env.timeout(60)
    with injection.request() as req:
        yield req
        start_time = env.now
        print("%s starting injection process at %s." % (patient, datetime.datetime.fromtimestamp(start_time).strftime('%X %p')), file=f)
        yield env.timeout(processing_time)
        finish_time = env.now
        print("%s finishing injection process at %s." % (patient, datetime.datetime.fromtimestamp(finish_time).strftime('%X %p')), file=f)
    total_delay_time = (start_time - arrival_time) / 60
    print("%s delayed %s minutes at the injection room" % (patient, total_delay_time), file=f)
    inj_delay_times.append(total_delay_time)
    inj_service_times.append(processing_time)
    flow[patient].update({
        'Injection': {
            'arrival': datetime.datetime.fromtimestamp(arrival_time).strftime('%X %p'),
            'start': datetime.datetime.fromtimestamp(start_time).strftime('%X %p'),
            'finish': datetime.datetime.fromtimestamp(finish_time).strftime('%X %p'),
            'delay': str(datetime.timedelta(minutes=total_delay_time))
        }
    })
    return total_delay_time

# Define patient flow
def patient_flow(env, bedspaces, doctors, registration, xray, scan, dressing, injection, pharmacy, billing, patient, f):
    global end, exit_time
    patient_type = p_type()
    total_delay_time = 0
    s_time = env.now
    end = 0
    flow[patient] = {}

    # Log patient type
    print("%s is a %s patient." % (patient, patient_type), file=f)

    # Decisions
    d0 = NewOP_decision()
    d1 = OldOP_decision()
    d2 = oldOP_scan_decision()
    criticality = assign_criticality()
    flow[patient]["criticality"] = criticality
    
    # Critical patients get bed allocation first
    if criticality == 'Level 1':
        total_delay_time += yield env.process(bedspace_allocation(env, bedspaces, patient, criticality, f))
        total_delay_time += yield env.process(registration_process(env, registration, patient, f))
    else:  # Non-critical patients: Registration first
        total_delay_time += yield env.process(registration_process(env, registration, patient, f))
        total_delay_time += yield env.process(bedspace_allocation(env, bedspaces, patient, criticality, f))
    if end == 0:
      # Patient flow based on type
      if patient_type == 'NewOP':
          if d0 == 0:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
          elif d0 == 1:
              print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
          elif d0 == 2:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
          elif d0 == 3:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
          elif d0 == 4:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
          elif d0 == 5:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
          elif d0 == 6:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
          elif d0 == 7:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(injection_process(env, injection, patient, f))
          elif d0 == 8:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(scan_process(env, scan, patient, f))
          elif d0 == 9:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
          elif d0 == 10:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(scan_process(env, scan, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))

      elif patient_type == 'OldOP':
          if d1 == 0:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
          elif d1 == 1:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
          elif d1 == 2:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
          elif d1 == 3:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
          elif d1 == 4:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
          elif d1 == 5:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
          elif d1 == 6:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
          elif d1 == 7:
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(injection_process(env, injection, patient, f))
          elif d1 == 8:
              # Incomplete flow
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)
          elif d1 == 9:
              # Incomplete flow
              print("%s left the hospital at %s" % (patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')), file=f)

      elif patient_type == 'OldOPScan':
          total_delay_time += yield env.process(billing_process(env, billing, patient, f))
          if d2 == 0:
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(dressing_process(env, dressing, patient, f))
          elif d2 == 1:
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(consultation(env, doctors, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
          elif d2 == 2:
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(billing_process(env, billing, patient, f))
              if end == 0:
                  total_delay_time += yield env.process(pharmacy_process(env, pharmacy, patient, f))
          elif d2 == 3:
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))
          elif d2 == 4:
              if end == 0:
                  total_delay_time += yield env.process(scan_process(env, scan, patient, f))

      elif patient_type == 'IP':
          ip_d = ip_decision()
          if ip_d == 1:
              if end == 0:
                  total_delay_time += yield env.process(scan_process(env, scan, patient, f))
          else:
              if end == 0:
                  total_delay_time += yield env.process(xray_process(env, xray, patient, f))

    # End processing and log times
    e_time = env.now
    processing_times.append((e_time - s_time) / 60)
    delay_times.append(total_delay_time)
    # if end == 1:
    #     left_patients.append([patient, datetime.datetime.fromtimestamp(env.now).strftime('%X %p')])
 

def save_and_close_plot(path, fname):
    """Helper function to save the plot and close it."""
    plt.savefig(os.path.join(path, fname), bbox_inches='tight')
    plt.close()

def plot_delay_times(delay_times, path, fname):
    """Plot patient delay times."""
    plt.plot(delay_times)
    plt.ylabel('Delay Time (minutes)')
    plt.xlabel('Patient ID')
    plt.title('Avg: {:.2f}, Min: {:.2f}, Max: {:.2f}'.format(np.average(delay_times), np.min(delay_times), np.max(delay_times)))
    save_and_close_plot(path, fname)

def plot_process_times(process_times, path, fname):
    """Plot patient processing times."""
    plt.plot(process_times)
    plt.ylabel('Processing Time (minutes)')
    plt.xlabel('Patient ID')
    plt.title('Avg: {:.2f}, Min: {:.2f}, Max: {:.2f}'.format(np.average(process_times), np.min(process_times), np.max(process_times)))
    save_and_close_plot(path, fname)

def plot_visits(services, visits, path, fname):
    """Plot number of visits per service."""
    plt.bar(services, visits)
    plt.ylabel('Visits')
    plt.xlabel('Services')
    plt.title('Avg: {:.2f}, Min: {:.2f}, Max: {:.2f}'.format(np.average(visits), np.min(visits), np.max(visits)))
    save_and_close_plot(path, fname)

def plot_service_delay_times(services, time, path, fname):
    """Plot average delay times per service."""
    plt.bar(services, time)
    plt.ylabel('Avg Delay Time (minutes)')
    plt.xlabel('Services')
    plt.title('Avg: {:.2f}, Min: {:.2f}, Max: {:.2f}'.format(np.average(time), np.min(time), np.max(time)))
    save_and_close_plot(path, fname)

def plot_service_process_times(services, time, path, fname):
    """Plot average processing times per service."""
    plt.bar(services, time)
    plt.ylabel('Avg Process Time (minutes)')
    plt.xlabel('Services')
    plt.title('Avg: {:.2f}, Min: {:.2f}, Max: {:.2f}'.format(np.average(time), np.min(time), np.max(time)))
    save_and_close_plot(path, fname)



def plot_patients_in_system(time_intervals, patients_in_system, path, fname):
    """
    Plot the number of patients in the system over time with integer-only y-axis ticks.
    """
    plt.figure(figsize=(14, 8))

    # Use plt.step for step-like plots
    plt.step(
        time_intervals, 
        patients_in_system, 
        where='post', 
        linestyle='-', 
        color='blue', 
        linewidth=2
    )

    # Add labels, title, and grid
    plt.title("Number of Patients in System Over Time")
    plt.xlabel("Time (minutes)")
    plt.ylabel("Number of Patients")
    plt.grid(True)

    # Force integer-only y-axis
    plt.gca().yaxis.set_major_locator(plt.MaxNLocator(integer=True))

    # Save and close the plot
    save_and_close_plot(path, fname)




# import gspread
# from google.oauth2.service_account import Credentials

def run_simulation(ui_inputs, current_index, init_csv_path="init.csv", baseline_arrivals_path="baseline_intervals.txt", results_dir="results"):
    # Load initialization and baseline intervals
    # global left_patients
    # left_patients = []  # Initialize the list to track patients who leave
    init = pd.read_csv(init_csv_path)
    baseline_arrivals = pd.read_csv(baseline_arrivals_path, header=None).values.flatten()

    # Extract constants from init.csv for the current index
    global NUM_PATIENTS, NUM_REGISTRATION_COUNTERS, REGISTRATION_TIME, NUM_DOCTORS, CONSULTATION_TIME
    global NUM_PHARMACY_COUNTERS, PHARMACY_TIME, NUM_BILLING_COUNTERS, BILLING_TIME
    global NUM_XRAY_COUNTERS, XRAY_TIME, NUM_SCAN_COUNTERS, SCAN_TIME
    global NUM_BEDSPACES, BEDSPACE_TIME, NUM_DRESSING_COUNTERS, NUM_INJECTION_COUNTERS
    global DRESSING_TIME, INJECTION_TIME, START_TIME, SERVICE_START_TIME, MAX_DELAY_TIME

    START_TIME = datetime.time(7, 30)  # 7:30 AM
    SERVICE_START_TIME = datetime.time(8, 0)  # 8:00 AM
    MAX_DELAY_TIME = 35 * 60  # 35 minutes in seconds

    # From init.csv
    REGISTRATION_TIME = init['REGISTRATION_TIME'][current_index] * 60
    CONSULTATION_TIME = init['CONSULTATION_TIME'][current_index] * 60
    PHARMACY_TIME = init['PHARMACY_TIME'][current_index] * 60
    BILLING_TIME = init['BILLING_TIME'][current_index] * 60
    XRAY_TIME = init['XRAY_TIME'][current_index] * 60
    SCAN_TIME = init['SCAN_TIME'][current_index] * 60
    BEDSPACE_TIME = init['BEDSPACE_TIME'][current_index] * 60
    DRESSING_TIME = init['DRESSING_TIME'][current_index] * 60
    INJECTION_TIME = init['INJECTION_TIME'][current_index] * 60
    NUM_DRESSING_COUNTERS = init['NUM_DRESSING_COUNTERS'][current_index]
    NUM_INJECTION_COUNTERS = init['NUM_INJECTION_COUNTERS'][current_index]

    # From UI
    NUM_PATIENTS = ui_inputs["NUM_PATIENTS"]
    # ARRIVAL_RATE = ui_inputs["ARRIVAL_RATE"]
    NUM_REGISTRATION_COUNTERS = ui_inputs["NUM_REGISTRATION_COUNTERS"]
    NUM_DOCTORS = ui_inputs["NUM_DOCTORS"]
    NUM_PHARMACY_COUNTERS = ui_inputs["NUM_PHARMACY_COUNTERS"]
    NUM_BILLING_COUNTERS = ui_inputs["NUM_BILLING_COUNTERS"]
    NUM_XRAY_COUNTERS = ui_inputs["NUM_XRAY_COUNTERS"]
    NUM_SCAN_COUNTERS = ui_inputs["NUM_SCAN_COUNTERS"]
    NUM_BEDSPACES = ui_inputs["NUM_BEDSPACES"]



    # Set up simulation environment
    env = simpy.Environment(initial_time=datetime.datetime.combine(datetime.date.today(), START_TIME).timestamp())

    # Resources
    doctors = simpy.PriorityResource(env, capacity=NUM_DOCTORS)
    registration = simpy.PriorityResource(env, capacity=NUM_REGISTRATION_COUNTERS)
    pharmacy = simpy.PriorityResource(env, capacity=NUM_PHARMACY_COUNTERS)
    billing = simpy.PriorityResource(env, capacity=NUM_BILLING_COUNTERS)
    scan = simpy.PriorityResource(env, capacity=NUM_SCAN_COUNTERS)
    xray = simpy.PriorityResource(env, capacity=NUM_XRAY_COUNTERS)
    dressing = simpy.PriorityResource(env, capacity=NUM_DRESSING_COUNTERS)
    injection = simpy.PriorityResource(env, capacity=NUM_INJECTION_COUNTERS)
    bedspace = simpy.PriorityResource(env, capacity=NUM_BEDSPACES)

    # Output paths and directory setup
    results_dir = os.path.join("static", "results")
    path = results_dir
    os.makedirs(path, exist_ok=True)
    log_file_path = os.path.join(path, "logs.txt")

    try:
        with open(log_file_path, "w") as log_file:
            log_file.write("Simulation log initialized.\n")  # Example log entry
    except Exception as e:
        print(f"Error writing log file: {e}")

    # Initialize data structures for metrics

    global num_registration, num_consultation, num_scan, num_pharmacy, num_xray, num_billing, num_dressing, num_injection, num_bedspace
    global delay_times, processing_times, flow
    global reg_delay_times, cons_delay_times, phar_delay_times, dress_delay_times
    global xray_delay_times, scan_delay_times, bill_delay_times, inj_delay_times, bedspace_delay_times
    global reg_service_times, cons_service_times, phar_service_times, dress_service_times
    global xray_service_times, scan_service_times, bill_service_times, inj_service_times, bedspace_service_times

    delay_times = []
    processing_times = []
    flow = {}
    patients_in_system = []
    time_intervals = []

    num_registration = 0
    num_consultation = 0
    num_scan = 0
    num_pharmacy = 0
    num_xray = 0
    num_billing = 0
    num_dressing = 0
    num_injection = 0
    num_bedspace = 0

    reg_delay_times = []
    cons_delay_times = []
    phar_delay_times = []
    dress_delay_times = []
    xray_delay_times = []
    scan_delay_times = []
    bill_delay_times = []
    inj_delay_times = []
    bedspace_delay_times = []

    reg_service_times = []
    cons_service_times = []
    phar_service_times = []
    dress_service_times = []
    xray_service_times = []
    scan_service_times = []
    bill_service_times = []
    inj_service_times = []
    bedspace_service_times = []

    
    def plot_patient_flow_heatmap(service_counts, interval, path, fname):
        """
        Plot a heatmap of patient flow through services over time.

        Args:
        - service_counts: Dictionary with service names as keys and patient counts over time as values.
        - interval: Monitoring interval in seconds.
        - path: Directory to save the plot.
        - fname: File name for the saved plot.
        """
        # Convert service counts into a 2D array for the heatmap
        services = list(service_counts.keys())
        data = np.array([service_counts[service] for service in services])

        # Generate time steps for the heatmap
        num_intervals = data.shape[1]
        time_steps = np.arange(0, num_intervals * interval, interval) / 60  # Convert to minutes

        # Plot the heatmap
        plt.figure(figsize=(15, 10))
        sns.heatmap(data, cmap="YlGnBu", xticklabels=10, yticklabels=services)
        plt.xlabel("Time (minutes)")
        plt.ylabel("Services")
        plt.title("Patient Flow Heatmap")
        save_and_close_plot(path, fname)




        

    def monitor_system(env, resources, patients_in_system, time_intervals, service_counts, interval=60):
        """
        Monitor the number of patients in the system and the flow through services for the heatmap.
        
        Args:
        - env: SimPy environment.
        - resources: Dictionary of service names and their corresponding SimPy resources.
        - patients_in_system: List to track the total number of patients in the system over time.
        - time_intervals: List to track the time intervals for monitoring.
        - service_counts: Dictionary to track patient counts for each service for heatmap data.
        - interval: Monitoring interval in seconds (default: 60 seconds).
        """
        start_time = env.now  # Record simulation start time

        while True:
            # Calculate the relative time (in minutes) since the start of the simulation
            relative_time = (env.now - start_time) / 60  # Convert seconds to minutes

            # Calculate total patients in queues and being processed
            total_patients_in_queues = sum(len(resource.queue) for resource in resources.values())
            total_patients_being_processed = sum(resource.count for resource in resources.values())
            total_patients = int(total_patients_in_queues + total_patients_being_processed)

            # Track the total number of patients in the system
            patients_in_system.append(total_patients)
            time_intervals.append(relative_time)  # Use relative time for plotting

            # Track the current patient count for each service
            for service_name, resource in resources.items():
                if service_name not in service_counts:
                    service_counts[service_name] = []
                service_counts[service_name].append(resource.count + len(resource.queue))  # Count in process + in queue

            # Check if simulation is done
            if total_patients == 0 and env.peek() == float("inf"):
                break

            yield env.timeout(interval)  # Monitor every `interval` seconds

    # Resources dictionary for tracking
    resources = {
        "Registration": registration,
        "Doctors": doctors,
        "Pharmacy": pharmacy,
        "Billing": billing,
        "Scan": scan,
        "Xray": xray,
        "Dressing": dressing,
        "Injection": injection,
    }

    # Lists and dictionaries for tracking
    patients_in_system = []
    time_intervals = []
    service_counts = {}

    # Start the monitoring process
    env.process(monitor_system(env, resources, patients_in_system, time_intervals, service_counts, interval=60))

    # Run the simulation
    with open(log_file_path, "w") as f:
        env.process(patient_arrival(env, bedspace, doctors, registration, xray, scan, dressing, injection, pharmacy, billing, f))
        env.run()

    # Generate plots and save data
    if delay_times:
        plot_delay_times(delay_times, path, 'delay_times.jpeg')
    if processing_times:
        plot_process_times(processing_times, path, 'processing_times.jpeg')

    services = ['R', 'C', 'P', 'D', 'X', 'S', 'B', 'I', 'Bed']
    visits = [num_registration, num_consultation, num_pharmacy, num_dressing, num_xray, num_scan, num_billing, num_injection, num_bedspace]
    if any(visits):
        plot_visits(services, visits, path, 'num_visits_per_service.jpeg')

    # Save detailed data
    np.savetxt(os.path.join(path, 'visits_per_service.txt'), visits)
    if any(reg_delay_times + cons_delay_times + phar_delay_times + dress_delay_times +
           xray_delay_times + scan_delay_times + bill_delay_times + inj_delay_times + bedspace_delay_times):
        np.savetxt(os.path.join(path, 'delay_times_per_process.txt'), reg_delay_times + cons_delay_times + phar_delay_times +
                   dress_delay_times + xray_delay_times + scan_delay_times + bill_delay_times +
                   inj_delay_times + bedspace_delay_times)
    if any(reg_service_times + cons_service_times + phar_service_times + dress_service_times +
           xray_service_times + scan_service_times + bill_service_times + inj_service_times + bedspace_service_times):
        np.savetxt(os.path.join(path, 'service_times_per_process.txt'), reg_service_times + cons_service_times + phar_service_times +
                   dress_service_times + xray_service_times + scan_service_times + bill_service_times +
                   inj_service_times + bedspace_service_times)

    # Calculate average delay times and service times per service
    service_labels = ['R', 'C', 'P', 'D', 'X', 'S', 'B', 'I', 'Bed']
    average_delay_times = [
        np.mean(reg_delay_times) if reg_delay_times else 0,
        np.mean(cons_delay_times) if cons_delay_times else 0,
        np.mean(phar_delay_times) if phar_delay_times else 0,
        np.mean(dress_delay_times) if dress_delay_times else 0,
        np.mean(xray_delay_times) if xray_delay_times else 0,
        np.mean(scan_delay_times) if scan_delay_times else 0,
        np.mean(bill_delay_times) if bill_delay_times else 0,
        np.mean(inj_delay_times) if inj_delay_times else 0,
        np.mean(bedspace_delay_times) if bedspace_delay_times else 0
    ]

    average_service_times = [
        np.mean(reg_service_times) / 60 if reg_service_times else 0,
        np.mean(cons_service_times) / 60 if cons_service_times else 0,
        np.mean(phar_service_times)/ 60 if phar_service_times else 0,
        np.mean(dress_service_times)/ 60 if dress_service_times else 0,
        np.mean(xray_service_times)/ 60 if xray_service_times else 0,
        np.mean(scan_service_times)/ 60 if scan_service_times else 0,
        np.mean(bill_service_times)/ 60 if bill_service_times else 0,
        np.mean(inj_service_times)/ 60 if inj_service_times else 0,
        np.mean(bedspace_service_times)/ 60 if bedspace_service_times else 0
    ]


    # Compute summary statistics

    avg_delay_time = round(np.mean(delay_times), 2) if delay_times else 0

    max_delay_time = round(np.max(delay_times), 2) if delay_times else 0

    min_delay_time = round(np.min(delay_times), 2) if delay_times else 0



    # Count critical and non-critical patients

    critical_patients = sum(1 for p in flow.values() if p.get("criticality") == "Level 1")

    non_critical_patients = sum(1 for p in flow.values() if p.get("criticality") != "Level 1")




    # Plot average delay times
    plot_service_delay_times(service_labels, average_delay_times, path, "average_delay_times_per_service.jpeg")

    # Plot average service times
    plot_service_process_times(service_labels, average_service_times, path, "average_service_times_per_service.jpeg")


    if flow:
        with open(os.path.join(path, 'flow_data.json'), 'w') as fp:
            json.dump(flow, fp)

        # Load JSON and ensure all keys are consistent across rows
        df = pd.read_json(os.path.join(path, 'flow_data.json'), orient='index')

        # Initialize missing columns (services) to "N/A"
        all_services = ['Registration', 'Consultation', 'Pharmacy', 'Dressing', 'Xray', 'Scan', 'Billing', 'Injection', 'Bedspace Allocation']
        for service in all_services:
            if service not in df.columns:
                df[service] = "N/A"

        # Replace remaining NaN values with "N/A"
        df.fillna("N/A", inplace=True)

        # Save the cleaned DataFrame
        df.reset_index(inplace=True)
        df.rename(columns={"index": "Patient"}, inplace=True)
        df.to_csv(os.path.join(path, 'flow_data.csv'), index=False)
    detailed_service_labels = ['Registration', 'Consultation', 'Pharmacy', 'Dressing', 'X-Ray', 'Scan', 'Billing', 'Injection', 'Bed']
    labeled_visit_counts = dict(zip(detailed_service_labels, visits))  # Create a labeled dictionary

    if patients_in_system and time_intervals:
        plot_patients_in_system(time_intervals, patients_in_system, path, "patients_in_system.jpeg")
    
    plot_patient_flow_heatmap(service_counts, interval=60, path=path, fname="patient_flow_heatmap.jpeg")

    # Return results for UI
    return {
        "path": path,
        "flow_data_csv": os.path.join(path, 'flow_data.csv') if flow else None,
        "visit_counts": labeled_visit_counts,
        "plots": {
            "delay_times": os.path.join(path, 'delay_times.jpeg') if delay_times else None,
            "processing_times": os.path.join(path, 'processing_times.jpeg') if processing_times else None,
            "visits_per_service": os.path.join(path, 'num_visits_per_service.jpeg') if any(visits) else None,
            "average_delay_times_per_service": os.path.join(path, 'average_delay_times_per_service.jpeg') if delay_times else None,
            "average_service_times_per_service": os.path.join(path, 'average_service_times_per_service.jpeg') if reg_service_times else None,
            "patients_in_system": os.path.join(path, "patients_in_system.jpeg") if patients_in_system else None,
            "patient_flow_heatmap": os.path.join(path, "patient_flow_heatmap.jpeg") if service_counts else None,
        },
        "logs": log_file_path,
        "delay_times": delay_times,
        "processing_times": processing_times,
        "summary": {
            "avg_delay_time": avg_delay_time,
            "max_delay_time": max_delay_time,
            "min_delay_time": min_delay_time,
            "critical_patients": critical_patients,
            "non_critical_patients": non_critical_patients,
        },
        "patient_types": flow,  # Includes patient criticality and types
    }

if __name__ == "__main__":
    # Example input parameters for testing
    example_inputs = {
        "NUM_PATIENTS": 50,
        "NUM_REGISTRATION_COUNTERS": 3,
        "NUM_DOCTORS": 2,
        "NUM_PHARMACY_COUNTERS": 2,
        "NUM_BILLING_COUNTERS": 2,
        "NUM_XRAY_COUNTERS": 1,
        "NUM_SCAN_COUNTERS": 1,
        "NUM_BEDSPACES": 5
    }
    current_index = 0  # Using the first row from init.csv

    # Run the simulation with the example inputs
    results = run_simulation(example_inputs, current_index)

    # Print the results
    print("Simulation results:")
    print(f"Results directory: {results['path']}")
    if results['flow_data_csv']:
        print(f"Flow data saved to: {results['flow_data_csv']}")
    print(f"Visit counts per service: {results['visit_counts']}")
    print("Generated plots:")
    if results['plots']['delay_times']:
        print(f" - Delay Times Plot: {results['plots']['delay_times']}")
    if results['plots']['processing_times']:
        print(f" - Processing Times Plot: {results['plots']['processing_times']}")
    if results['plots']['visits_per_service']:
        print(f" - Visits Per Service Plot: {results['plots']['visits_per_service']}")
    if results['plots']['average_delay_times_per_service']:
        print(f" - Average Delay Times Per Service Plot: {results['plots']['average_delay_times_per_service']}")
    if results['plots']['average_service_times_per_service']:
        print(f" - Average Service Times Per Service Plot: {results['plots']['average_service_times_per_service']}")
    if results['logs']:
        print(f"Logs saved to: {results['logs']}")